.SYNTAX PROGRAM

OUT1 = '*' .OUT('      push(in_buf)')
	/ .STRING .OUT('      push('*')').,

OUTPUT = '.out' '(' $OUTA ')' .OUT('      out()')
	/ '{' .OUT('      indent+=1')
	/ '}' .OUT('      indent-=1')
	/ '\n' .OUT('      out()').,

EX3 = .ID .OUT('      e_'*'()')
	/ .STRING .OUT('      get_literal( '*' )')
	/ '.ID'		 .OUT('      get_tok()')
	/ '.NUMBER' .OUT('      get_num()')
	/ '.STRING' .OUT('      get_str()')
	/ '(' EX1 ')'
	/ '.EMPTY' .OUT('      flag = 1')
	/ '$' .OUT('      flag = 1') .OUT('      while flag:') EX3 .,

EX2 = (EX3 .OUT('    if flag:') / OUTPUT .OUT('    if True:'))
	$(EX3 .OUT('    check_err()') / OUTPUT).,

EX1 = .OUT('  while True:') EX2 $('/' .OUT('    if flag: break') EX2 )
.OUT('    break') .,

STATEMENT = .ID .OUT('def e_' * '():') '=' EX1
';' .OUT('').,

PROGRAM = '.SYNTAX' .ID .OUT('
import string
import sys
indent = 0
out_buf = ""
in_buf = ""
flag = 0
def push(x): out_buf += x
def out(): print("\t"*indent + out_buf); out_buf=""
def check_err(): if flag: print("ERROR"); sys.exit(1)
def skip():
		while input.peek(1)[:1] in b" \t\n": input.seek(1, 1)
def read(t):
		skip(); n = input.peek(1)[:1].decode()
		if not((t=="id" and n in string.printable[10:62]+".")
				or (t=="str" and ord(n) == 39)
				or (t=="num" and n in string.printable[:10])):
				flag = 0; return
		global in_buf; in_buf = n; input.seek(1, 1); flag = 1
		while n := input.peek(1)[:1].decode():
				if not ((t=="id" and n in string.printable[:62])
						or (t=="str" and ord(n) != 39)
						or (t=="num" and n in string.printable[:10])): break
				in_buf += n; input.seek(1, 1);
def test(x):
		skip(); global flag
		if input.peek(len(x))[:len(x)] == x.encode():
				input.seek(len(x), 1); flag = 1
		else: flag = 0

if len(sys.argv) < 1:
	print(f"Usage: {sys.argv[0]} <program_file>")
else:
	input = open(sys.argv[1], "rb")
	' * '()

') $ STATEMENT '.END'.,

.END
